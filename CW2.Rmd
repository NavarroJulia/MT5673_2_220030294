---
title: "Monte Carlo simulation (R)"
author: "Julia Navarro"
date: "October 2022"
output: html_document
---
    
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Problem A 

<!--- Tasks:

Problem A
• Consider the following independent random variables:
– X ∼ N (µ = 4, σ2 = 10)
– Y ∼ U(a = 2, b = 8)
• Compute the probability that X > Y , i.e. Pr(X > Y ).
• Use bootstrapping to derive the sampling distribution for your estimate of Pr(X > Y ).
• Show how the sample variance of this sampling distribution changes as a function of the number of
Monte Carlo simulations.

--->
 
``` {r, echo = FALSE}

library(parallel)
library(ggplot2)
library(dplyr)

detectCores()

## 8 
##clusterExport(cl, ls())

## check the system code ##
#profvis



## Compute the probability that X > Y , i.e. Pr(X > Y ):

num_sim = 100

set.seed(314)

Prob_calc <- function(){

## create a vector of length num_sim of all zeros:
P <- rep(0, num_sim) 

for(i in 1:num_sim){

X <- rnorm(1, mean=4, sd=sqrt(10))
Y <- runif(1, min=2, max=8)

if(X>Y){
  
  P[i] <- 1
  
      }
}

print(sum(P)/num_sim)

}
# run: 
Prob_calc()


## Use bootstrapping to derive the sampling distribution for your estimate of Pr(X > Y)


## calculate each probability and store it in vector and then find sampling distribution

## set seed:
set.seed(413)

## create vectors of probabilities:
x <- rnorm(num_sim, mean=4, sd=sqrt(10))
y <- runif(num_sim, min=2, max=8)

## store in data.frame:
obsData <- data.frame(x, y) 




## need data from both X and Y. We then use the bootstrap method with replacement and apply the function
## as used above to calculate the probability (need to derive a sampling distribution)


# Initialisation

NRepeat <- 50 # no. of bootstrapped samples

## Column of results (propbabilities of each bootstrap iteration)

bootRes <- matrix(data = 0, nrow = NRepeat, ncol = 1) 


S <- rep(0, num_sim)



## Loop across all samples:


for (i in 1:(NRepeat)){
  
  ## Resample with replacement:
  
  bootData <- obsData[sample(x = num_sim, size = num_sim, replace = T),]
  
  
  ## calculate the probability associated with this new shuffled data:
  
  for (j in 1:nrow(bootData)){
    
    if(bootData[j,1] > bootData[j,2]){
      
      S[j] <- 1
      
    }}
    
    
      
      bootRes[i] <- (sum(S)/num_sim)
      
      S <- rep(0, num_sim) 
  
}

#print(bootRes)

summary(bootRes)
hist(bootRes)

# boxplot?

```

## Problem B

<!--- 


Problem B
• Consider the following football tournament format: a team keeps playing until they accrue 7 wins or 3
losses (whichever comes first - no draws allowed). Assume a fixed win rate p ∈ [0, 1] across all rounds
(they are paired at random).
• Plot how the total number of matches played (i.e. wins + losses) varies as a function of p.
• Comment on the observed win rate relative to the assumed win rate p (i.e. if a team obtains 2 wins -
3 losses, the maximum likelihood point estimate for their win rate is 40%). Specifically, focus on the
effect driven by the format of this tournament.


--->



```{r, echo = FALSE}
N_Repeat <- 50# no. of competitions entered 



## For one game:

Loop <- function (j){
  
  set.seed(j)
  
  
  WINorLOSS = c(data = NULL)
  
  ## fixed prob over all games
  pw <- runif(n = 1, min = 0, max = 1)  
  pl <- 1 - pw  
  ## create vector of two random probabilities: pw or pl
  r = 10
  x = rep(c(pw,pl), each= r)
  
  
  ## Randomize probabilities:
  
  rand <- sample(x)        #  use Sample 
  
  Total_game = c()
  
  
  
  
  for (i in 1:length(rand)) {
    
    
    
    if (rand[i] == pw){
      
      WINorLOSS <- c(WINorLOSS, 1)
      
    } 
    
    if (rand[i] == pl){
      WINorLOSS <- c(WINorLOSS, 0)
    } 
    
    if (sum(length(WINorLOSS[WINorLOSS == 1])) == 7 | sum(length(WINorLOSS[WINorLOSS == 0])) == 3){
      Prob_perGame = c()     
      Prob_perGame <- pw
      Total_game <- length(WINorLOSS)
      {break}
      
    }
    
    
  }
  
  z1<-Total_game
  z2<-pw  
  z3<-z1*z2 #games won
  z4<-z1 - z3 #games lost
  Z<-data.frame(z1, z2, z3, z4)
  
  
  
}



n1 = c()
n2 = c()
n3 = c()
n4 = c()

for (k in 1:N_Repeat) {
  n1[k] <- dplyr::pull(Loop(k), z1)  #pull out nbr of games
  n2[k] <- dplyr::pull(Loop(k), z2)  #pull out win rate
  n3[k] <- dplyr::pull(Loop(k), z3)  #pull out win count
  n4[k] <- dplyr::pull(Loop(k), z4)  #pull out loss count
} 

#Round to nearest integer

n3 <-round(n3) 
n4 <- round(n4)






Tgames <- n1 # total games
pWin <- n2 # prob of winning in game
Game_won <- n3 # games won
Game_lost = n4 # games lost



plot(n2, n1)

plot(n1,n3, col = "blue") #nbr of games won

#points(n1,n4, col = "red") 
plot(n1,n4, col = "red") #nbr of games lost

WinRate <- pWin
ObservedWinRate  <- Game_won/Tgames

plot(WinRate, ObservedWinRate)






```
