---
title: "Monte Carlo simulation (R)"
author: "Julia Navarro"
date: "October 2022"
output: html_document
---
    
    
    
```{r setup, include=FALSE, comment=NA}

knitr::opts_chunk$set(echo = FALSE)


```



```{r load-packages, include=FALSE, comment=NA}
library(parallel)
library(ggplot2)
library(dplyr)
```


<br>


## Problem A (simulation of a probability)

<!--- Tasks:

Problem A
• Consider the following independent random variables:
– X ∼ N (µ = 4, σ2 = 10)
– Y ∼ U(a = 2, b = 8)
• Compute the probability that X > Y , i.e. Pr(X > Y ).

--->

<br>

Our first task involves the calculation of the probability that $X ∼ N (µ = 4,\;σ^2 = 10)$ is larger than $Y∼ U(a = 2,\:b = 8)$. We begin by generating an empty vector $\hat{P}$ of all zeros in which our values ($0$ or $1$) will be stored in. Next, we create a for loop so that each time a random pain of X and Y are printed. They are subsequently compared and if $X$ is in fact larger than $Y$, a "1" it placed in the $i^{th}$ position in the zero vector, There is no need to worry to what happens if Y>=x as the null vector already accomodates this condition by default. We can choose the number of loops we would like, and note that increasing this will result in a more accurate probability $P(X>Y)$. After the loop has ended we simply sum up the components in $\hat{P}$ and divide by the number of loops (or random pairs generated). This gives us an approximation to the probability:

<br>

``` {r, echo = FALSE, comment=NA}

## check the system code ##
#profvis



## Compute the probability that X > Y , i.e. Pr(X > Y ):

num_sim = 50

set.seed(314)

Prob_calc <- function(){

## create a vector of length num_sim of all zeros:
P <- rep(0, num_sim) 

for(i in 1:num_sim){

X <- rnorm(1, mean=4, sd=sqrt(10))
Y <- runif(1, min=2, max=8)

if(X>Y){
  
  P[i] <- 1
  
      }
}

print(sum(P)/num_sim)

}
# run: 
Prob_calc()


```
<br>

<!---


• Use bootstrapping to derive the sampling distribution for your estimate of Pr(X > Y ).
• Show how the sample variance of this sampling distribution changes as a function of the number of
Monte Carlo simulations.

--->

Having now obtained a method to approximate our probability, we will now use the bootstrapping method. This will allow us to investigate the how the sample variance of this sampling distribution changes with respect to the number of times the monte carlo simulation is performed. Similarly as we did in the prior calculation, we will generate random $X$ and $Y$ values ($X,\:Y$ both of size `r num_sim`, the number of simulations performed). For example if the number of loops ran was 50 we could use the bootstrap method to repeatedly sample with replacement and obtain a range of probabilities associated with each new iteration of bootstrapping.


We create a data framae object and input these new randomly choosen values for $X$ and $Y$. The loop compares the first and second column values from the the $j^{th}$ row. If the one for $X$ is larger, again, assign a vector the value 1 at this value of the loop. Repeat this for all $j$ values and find the probability and store this in the $i^{th}$ entry of our result vector. The two for loops, once concluded, will yield a vector of probabilities. We can analysise how it differs compared to the exact value for the probability (see the summary output). Note how the probabilities vary.
 
<br>

```{r, echo = FALSE, comment=NA}




## calculate each probability and store it in vector and then find sampling distribution


## Show how the sample variance of this sampling distribution changes as a function of the number of
## Monte Carlo simulations.




## create vectors of probabilities:
x <- rnorm(num_sim, mean=4, sd=sqrt(10))
y <- runif(num_sim, min=2, max=8)

## store in data.frame:
obsData <- data.frame(x, y) 




## need data from both X and Y. We then use the bootstrap method with replacement and apply the function
## as used above to calculate the probability (need to derive a sampling distribution)


# Initialisation

NRepeat <- 50 # no. of bootstrapped samples

## Column of results (propbabilities of each bootstrap iteration)

bootRes <- matrix(data = 0, nrow = NRepeat, ncol = 1) 


S <- rep(0, num_sim)



## Loop across all samples:


for (i in 1:(NRepeat)){
  
  ## Resample with replacement:
  
  bootData <- obsData[sample(x = num_sim, size = num_sim, replace = T),]
  
  
  ## calculate the probability associated with this new shuffled data:
  
  for (j in 1:nrow(bootData)){
    
    if(bootData[j,1] > bootData[j,2]){
      
      S[j] <- 1
      
    }}
    
    
      
      bootRes[i] <- (sum(S)/num_sim)
      
      S <- rep(0, num_sim) 
  
}

#print(bootRes)

## create table of min, max, median and mean

#summary(bootRes)
#hist(bootRes)
#Mean <- summary(bootRes)[4,]

# boxplot?



## variance per bootstrap

```

| Statistic calculated:| Values:
|:---------------- |:---------------------
| Min. Value      |    `r min(bootRes) `|                   
| Max.  Value     |`r max(bootRes)`     |
|  Median         | `r median(bootRes)` |
 |  Mean          |  `r mean(bootRes)`  |


<br>

One can notice that as the number of simulations increases, the values in the above table tend to a certain value (the actual probability). Thus, the more times the monte carlo simulation for the probability is computed, the more accurate the bootstap approximation becomes.

<br><br>

## Problem B

<br>

<!--- 


Problem B
• Consider the following football tournament format: a team keeps playing until they accrue 7 wins or 3
losses (whichever comes first - no draws allowed). Assume a fixed win rate p ∈ [0, 1] across all rounds
(they are paired at random).
• Plot how the total number of matches played (i.e. wins + losses) varies as a function of p.
• Comment on the observed win rate relative to the assumed win rate p (i.e. if a team obtains 2 wins -
3 losses, the maximum likelihood point estimate for their win rate is 40%). Specifically, focus on the
effect driven by the format of this tournament.


--->

The next problem at hand is the monte carlo simulation of a hypotheical football game of a team. The rules are as follows: 3 losses or 7 wins (no draws permitted) will result in the termination of the tournament. The goal is to find the expected number of games that will be played as a result of these conditions and where the scoring (win) probability is fixed. Moreover, we would like to compare how the predicted wins differ to the observed successes.

<!---

Explain how we went about coding this problem:

--->

The basic idea is to translate one competition into a function, then loop the function over $j$ values (the function, Loop(), is a function of $j$). To ensure that each competition has a fixed win rate, we set the seed in the $j^{th}$ iteration a $j$. We then randomly generate a value for the win rate ($p_w\;\in\;(0,\;1)$) and lose rate ($p_l = 1 - p_w$), and assign these to a vector $x$. Each win and loss rate is placed into the vector 30 times and then we sample this vector (shuffle the probabilities in $x$ into a new vector, *rand* ). Then begin a loop which last 9 iterations (number of maximum number of games possible) and check whether in the $i^{th}$ position there is a $p_w$ value or a $p_l$ value in *rand*. If our winning probability is present, another vector, accounting for the games played (*WINorLoss*), receives a 1 in this position of the iteration. If a losing probability is detected, a 0 is placed in the vector at the step. Each time this is performed we must check that the number of 1s and 0s does not exceed 7 or 3, respectively. If it does, and it will, we break out of the loop.



```{r, echo = FALSE}
N_Repeat <- 20# no. of competitions entered 



## For one game:

Loop <- function (j){
  
  set.seed(j)
  
  
  WINorLOSS = c(data = NULL)
  
  ## fixed prob over all games
  pw <- runif(n = 1, min = 0, max = 1)  
  pl <- 1 - pw  
  ## create vector of two random probabilities: pw or pl
  r = 30
  x = rep(c(pw,pl), each= r)
  
  
  ## Randomize probabilities:
  
  rand <- sample(x)        # sample our x vector  
  
  Total_game = c()
  
  
  
  
  for (i in 1:9) {
    
    
    
    if (rand[i] == pw){
      
      WINorLOSS <- c(WINorLOSS, 1)
      
    } 
    
    if (rand[i] == pl){
      WINorLOSS <- c(WINorLOSS, 0)
    } 
    
    if (sum(length(WINorLOSS[WINorLOSS == 1])) == 7 | sum(length(WINorLOSS[WINorLOSS == 0])) == 3){
      Prob_perGame = c()     
      Prob_perGame <- pw
      Total_game <- length(WINorLOSS)
      {break}
      
    }
    
    
  }
  
  z1<-Total_game
  z2<-pw  
  z3<-z1*z2 #games won
  z4<-z1 - z3 #games lost
  Z<-data.frame(z1, z2, z3, z4)
  
  
  
}



n1 = c()
n2 = c()
n3 = c()
n4 = c()

for (k in 1:N_Repeat) {
  n1[k] <- dplyr::pull(Loop(k), z1)  #pull out nbr of games
  n2[k] <- dplyr::pull(Loop(k), z2)  #pull out win rate
  n3[k] <- dplyr::pull(Loop(k), z3)  #pull out win count
  n4[k] <- dplyr::pull(Loop(k), z4)  #pull out loss count
} 

#Round to nearest integer

n3 <-round(n3) 
n4 <- round(n4)






Tgames = n1 # total games
pWin = n2 # prob of winning in game
Game_won = n3 # games won
Game_lost = n4 # games lost


#plot(n2, n1)

#plot(n1,n3, col = "blue") #nbr of games won

#points(n1,n4, col = "red") 
#plot(n1,n4, col = "red") #nbr of games lost

WinRate <- pWin
ObservedWinRate  <- Game_won/Tgames

```


To repeat this process such that we simulate multiple tournaments, we loop $j$ = `r N_Repeat` times. Each iteration of this particular loop, we extract vectors containing: the total games played, the winning probability associated with this specific tournament, and the games lost and won. We need to ensure that the number of games won/lost are positive integers so we round them. Lastly, we rename them appropriate to use later for plotting purposes.



```{r, echo = FALSE}

plot(WinRate, ObservedWinRate, pch = 20)
abline(a=0, b=1, col = "blue", lwd = 2) ## diagonal line y = x
abline(lm(WinRate ~ ObservedWinRate), col = "red", lty = 2, lwd = 2) ## fitted line

DataF <- data.frame(Tgames, WinRate)

LossRate = 1 - WinRate

Dataf <- data.frame(Tgames, LossRate)


  ggplot(DataF) +
  geom_col(aes(y = Tgames, x = WinRate), width = 0.008)
  
   ggplot(Dataf) +
  geom_col(aes(y = Tgames, x = LossRate))




```
